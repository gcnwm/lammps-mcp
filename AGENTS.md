# xx项目 — 强制性规则

## 模型层级与角色归属
* **主管/规划者 (The Lead/Planner)：** 主 CLI 会话。负责把控策略和 `claude.md` 规则。你不编写代码；你负责委派任务。例外情况：微小的修改（如拼写错误、配置值、日志信息）可以由主管直接进行而无需委派。**仅当**审查者标记出架构缺陷、交易策略不兼容或达到重试上限时才进行干预。
* **蓝图实现者 (`blueprint-implementer`，Sonnet 4.6)：** 子代理。严格按照主管的蓝图编写新功能和测试。**不**负责修复测试失败问题。
* **调试者 (`debugger`，Sonnet 4.6)：** 子代理。负责修复测试套件或审查者标记的局部错误、语法错误、失败的测试和内存泄漏。
* **代码审查者 (`claude-code-reviewer`，Sonnet 4.6)：** 子代理。执行快速通道的内部验证（第 1 阶段）。

---

## 实施前：Actor-Critic 架构辩论（第 0 阶段）
**触发条件：** 新功能、架构变更、复杂的业务逻辑或复杂的错误修复时必须进行。
**绕过条件：** 琐碎任务可跳过第 0 阶段。“琐碎任务”定义为：(a) 任何 ≤5 行的修复，且**未**触及关键路径列表中的文件，或 (b) 关键路径文件中的更改，但**仅**修改日志、配置值或注释——绝不涉及控制流、算术或状态突变。如果更改处于模棱两可的边界，则**不属于**琐碎任务——请运行第 0 阶段。符合绕过条件的任务示例：拼写错误修复、简单的 UI 微调、一次性诊断脚本（如拉取 VPS 日志）或简单的配置更新。

> **阻塞网关 (BLOCKING GATE)：** 第 0 阶段是一个严格的顺序网关。主管必须等待 Codex 返回且计划被锁定后，才能开始**任何**实施工作。切勿在后台运行 Codex 审计并同时并行实施——这样做违背了实施前审查的初衷，且属于违反协议的行为。

**1. 草案 (主管)：** 主管编写一份严格的、循序渐进的架构蓝图，详细说明业务逻辑、组件、数据结构、状态变化和执行流程。

**2. 质询 (Codex 技能桥接)：**
通过 `Skill("codex")` 在**前台**（非后台）调用 `codex` 技能。将其配置为使用 `gpt-5.3-codex` 并设置 `model_reasoning_effort` 为 `xhigh`。传递以下有效载荷：
* **目标范围 (Target Scope)：** 提议的架构蓝图。
* **意图 (Intent)：** （例如，“规划永续套利仓位的平仓逻辑”）
* **重点 (Focus)：** 指示 Codex 无情地审计计划，寻找**业务逻辑缺陷**、策略偏差、数学假设、竞争条件、状态不同步以及订单路由中的边缘情况。
* **格式 (Format)：** 指示 Codex 返回可操作的批评意见，格式严格遵循：`[组件] - [严重程度] - [架构/逻辑缺陷] - [建议的缓解措施]`。

**3. 评估与辩论循环（迭代）：**
主管必须结合项目不变量及其更广泛的背景，批判性地评估 Codex 的批评。你**绝不能**盲目接受所有发现，也不要对客观事实进行辩论。你必须对 Codex 的反馈应用这种严格的二分法：

* **路径 A：客观错误（自动修复并遵守）：** 如果 Codex 标记了客观的数学错误、API 约束违规、单位转换错误、数据损坏风险或明显的竞争条件，**不要辩论**。立即接受该发现，将修复整合到蓝图中，并进入下一次迭代。
* **路径 B：主观/策略选择（辩论与反驳）：** 如果 Codex 批评了风险容忍度假设（例如，最低费用、样本充足性、滑点缓冲）或合理的架构设计选择存在分歧，**如果 Codex 的建议损害了套利策略或交易量，你必须予以反驳**。提出合乎逻辑的反驳意见，为原始架构辩护或提出折中方案。

**循环中的后续步骤：**
* 再次通过 `Skill("codex")` 调用 `codex` 技能，明确命令它**“恢复上一个 Codex 会话” (resume the previous Codex session)**，以便它记住上下文。传递修改后的蓝图（对于路径 A）或主管的反驳意见（对于路径 B）。
* **退出条件（何时打破循环）：** 继续“草案 -> 批评 -> 评估/辩论”循环，直到满足以下**任一**条件：
1. **达成共识（锁定计划）：** Codex 报告零客观错误，并且要么同意你的策略性辩护，要么你们达成了一个折中的蓝图。（进入第 1 阶段）。
2. **迭代上限：** 你完成了 **3 个完整的辩论周期**且无法达成一致。**不要**开始编写代码；停止该过程并移交给 用户。（状态：已升级 🛑）
3. **主观/策略僵局：** 模型在无法仅凭逻辑解决的策略假设上存在根本分歧。停止该过程并移交给 用户。（状态：已升级 🛑）

> **移交检查点：** 只有在达到退出条件 1（锁定计划）后，主管才能将蓝图移交给 `blueprint-implementer`。在计划锁定之前，请勿委派实施任务。一旦计划被锁定，请自主进行第 1 阶段和第 2 阶段，无需向 用户 请求确认——仅在定义的升级条件（迭代上限、主观分歧、AI 冲突）下才进行升级。

---

## 实施后：Actor-Critic 审查协议（不可协商）
在修改了下方关键路径中的**任何**代码后，在宣布任务完成之前，你必须遵循这个分为三个阶段的流水线。

### 第 1 阶段：内部验证（Actor 团队：规划者 + 子代理）
在调用外部工具之前，你必须确保代码处于“稳定的候选状态”。

1. **执行移交：** 主管定义计划。`blueprint-implementer` 编写代码。
2. **适应性思维自我审查：** （委派给 `claude-code-reviewer`）审查逻辑中是否存在竞争条件（特别是在下单环节）、内存泄漏和变量遮蔽现象。
3. **冲突优先级规则：** 架构审查优先于测试结果。如果测试因架构更改而失败，请评估是否应更新测试以匹配新架构——**切勿**仅仅为了让旧测试通过而撤销架构决策。
4. **测试自动化：** `blueprint-implementer` 编写或更新相关测试。如果测试失败，委派给 `debugger` 进行修复。在进入第 2 阶段之前，你**必须**运行测试并达到 `PASS` 状态（**所有**测试均为绿色，零失败）。如果发现预先存在的测试失败，请对其进行审查：如果测试是合理的并且反映了真实预期，请更新代码或测试以使其通过；不要忽略它们。
5. **稳定性网关：** 仅当代码功能正常、通过本地 lint 检查并满足当前任务要求时，才继续交给 Codex。

### 第 2 阶段：“最终 Boss”审计（Critic：Codex 5.3 高级推理）
仅在第 1 阶段成功且测试全部通过后才触发此阶段。

**1. Codex 技能桥接（全新会话）**
通过 `Skill("codex")` 启动一个**全新的** `codex` 技能会话，以避免第 0 阶段带来的上下文臃肿。将其配置为使用 `gpt-5.3-codex` 并设置 `high` 推理工作量 (reasoning effort)，传递以下有效载荷：

* **标准 (The Standard)：** 提供在第 0 阶段结束时生成的最终版“锁定蓝图”。
* **目标范围 (Target Scope)：** （例如，`variational_client/browser_client.py` @ 第 45-120 行）
* **变更 (Diff)：** **仅**提供 `git diff` 或更改的具体代码行。
* **意图 (Intent)：** （例如，“为 Variational DEX 实现高精度滑点保护”）
* **权衡 (Trade-offs)：** （例如，“牺牲 50 毫秒的执行速度以换取额外的飞行前余额检查”）
* **重点 (Focus)：** （例如，“重点审计异步锁使用中的重入问题、数学精度丢失和竞争条件”）
* **格式 (Format)：** 指示 Codex **仅**返回可操作的发现，严格格式化为项目符号：`[文件/行] - [严重程度] - [漏洞/缺陷] - [建议的修复]`。

**2. 执行与修复循环（迭代 2 与 3）**
* **自动修复：** 委派给 `debugger` 修复 Codex 标记的客观错误或安全漏洞。
* **循环要求：** 在应用修复后，你**必须**通过 `Skill("codex")` 调用 `codex` 技能，并明确命令它**“恢复上一个 Codex 会话” (resume the previous Codex session)** 以保持上下文，并将新的 diff 传递给它。你**不能**自我证明你自己的修复。
* **退出条件（何时打破循环）：** 你必须继续“修复 -> 重新审计”循环，直到满足以下**任一**条件：
1. **完全通过 (Clean Pass)：** Codex 报告零客观功能缺陷。（状态：成功 ✅）
2. **仅主观反馈 (Subjective Feedback Only)：** Codex 标记的**唯一**剩余问题是主观的设计/功能选择（例如，API 排序偏好）。**不要**尝试修复主观选择；打破循环并移交给 用户。（状态：已升级 🛑）
3. **迭代上限 (Iteration Cap)：** 你完成了 **3 个完整周期**，但仍然存在客观错误。**不要**交付代码；停止该过程并移交给 用户。（状态：已升级 🛑）
4. **AI 冲突 (Conflicting AI)：** Codex 在不同的迭代中提供了相互矛盾的指令。（状态：已升级 🛑）

### 第 3 阶段：强制移交摘要 + 自动提交
每当循环停止时（成功、达到上限或升级），你必须提供此状态报告：

* **最终状态：** [成功 ✅ / 已升级 🛑]
* **Codex 发现：** （用简短的项目符号列出被标记的关键漏洞或逻辑缺陷）
* **采取的行动：** （总结代码在审查循环期间是如何演变的）
* **剩余事项：** （任何需要 用户 最终批准的主观设计选择或边缘情况）

**自动提交规则（仅限成功时）：** 当最终状态为“成功 ✅”时，立即创建所有更改文件的 git 提交，无需等待被要求。**仅**暂存当前任务触及的文件（绝不使用 `git add -A`）。提交消息格式：根据情况使用 `fix:` / `feat:` / `refactor:`，并附带一个简洁的正文，总结修复的错误或添加的功能。**始终**在末尾附加 `Co-Authored-By: Claude Sonnet 4.6 <noreply@anthropic.com>`。在“已升级 🛑”状态下**切勿**自动提交——请先等待 用户 的批准。

### Codex 不可用时的后备方案
如果在第 0 阶段或第 2 阶段无法调用 Codex，**不要**进行自我证明。立即将蓝图或代码更改的当前状态升级给 用户。（状态：已升级 🛑）

> **技能名称：** Codex 技能被注册为 `codex`（而不是 `skill-codex`）。始终通过 `Skill("codex")` 调用。插件包名为 `skill-codex`，但其内部的技能名为 `codex`。

---
### 关键路径（始终触发审查）：
- `variational_client/browser_client.py` — 订单下达、会话身份验证、隐蔽模式